import sys
import random
import re
import json
from decimal import Decimal, ROUND_HALF_UP

IS_PYTHON_2 = sys.version_info < (3,)
if IS_PYTHON_2:
    STRING_TYPE = basestring
else:
    STRING_TYPE = str

PATTERN_PARAM_DELIMITER = r'\s{1,}'

TYPE_STRINGS = ('string', 'str')
TYPE_BOOLEANS = ('boolean', 'bool')
TYPE_INTEGERS = ('integer', 'int')

"""
Generate Json base on a schema and value from args dictionary

1. Basic 
    Here is an example schema:
    |   {                                                           |
    |       "name": "string",                                       |   
    |       "id": "integer random_int(0, 10)",                      |
    |       "sof": {                                                |
    |           "number": "string random_string(5, '0123456789')",  |
    |           "amount": "string random_decimal(10.5, 20.5, 1)",   |
    |           "is_deleted": "boolean random_bool()"               |
    |       }                                                       |
    |   }                                                           |
    
    Each field of schema will follow this format: <data_type> <python_expression>
    There're 3 data types: string (str), integer (int), boolean (bool)
    <python_expression> will be evaluated to generate field if there isn't any provided value from args dict.
    Some available expressions:
        - random_string(size, chars)
        - random_int(min, max)
        - random_bool()
        - random_decimal(min, max, decimal_digits)
        - random_enum(*args)
    
    To provide value for a field, you can use it's json path as key. 
    If a field doesn't have default or provided value, then it will be omitted from result.
    
    Here is some json result generated by above schema with different arguments:
    
    |       args                |              result               |
    =================================================================
    |                           |   {                               |
    |                           |       "id": 2,                    |
    |                           |       "sof": {                    |
    |                           |           "number": "64386",      |
    |                           |           "amount": "16.7",       |
    |                           |           "is_deleted": false     |
    |                           |       }                           |
    |                           |   }                               |
    =================================================================
    | "$.name":"user_1"         |   {                               |
    | "$.sof.number":"12345"    |       "name": "user_1",           |   
    | "$.sof.amount":None       |       "id": 5,                    |
    |                           |       "sof": {                    |
    |                           |           "number": "12345",      |
    |                           |           "amount": null,         |
    |                           |           "is_deleted": true      |
    |                           |       }                           |
    |                           |   }                               |
    =================================================================
    | "$.name": 123             |   {                               |
    | "$.sof":None              |       "name": "123",              |   
    |                           |       "id": 5,                    |
    |                           |       "sof": null                 |
    |                           |   }                               |
    
2. Generate array
    Here is an example schema:
    |   [                                                           |
    |       {                                                       |
    |           "id": "integer",                                    |
    |           "sub": [ "string random_string(3, 'abcdef')" ]      |
    |       }                                                       |
    |   ]                                                           |
    By default, it will generate only 1 item for an array (you can control default size by default_array_items option). 
    To control how many items should be generated, you can use json_path with .length()
    Here is some json result generated by above schema with different arguments:
    
    |       args                |              result               |
    =================================================================
    |                           |   [                               |
    |                           |       {                           |   
    |                           |           "sub": [ "afd" ]        |
    |                           |       }                           |
    |                           |   ]                               |
    =================================================================
    |   "$.length()": 2         |   [                               |
    |   "$[0].sub.length()": 2  |       {                           |   
    |   "$[1].id":5             |           "sub": [ "cab", "bfd" ] |
    |                           |       },                          |
    |                           |       {                           |
    |                           |           "id": 5,                |
    |                           |           "sub": [ "ebc" ]        |
    |                           |       }                           |
    |                           |   ]                               |
    =================================================================
    |   "$.length()": 2         |   [                               |
    |   "$[1].sub": ["a", "b"]  |       {                           |   
    |   "$[*].id":5             |           "id": 5,                |
    |                           |           "sub": [ "cab" ]        |
    |                           |       },                          |
    |                           |       {                           |
    |                           |           "id": 5,                |
    |                           |           "sub": [ "a", "b" ]     |
    |                           |       }                           |
    |                           |   ]                               |
    
    You can use * wildcard to pass value for all items in array. 
    Note that when it fetch value from args dict, if there're many key matched with current json_path, 
    it will use last matched key that is sorted by ABC order.
    
3. Option
- remove_null: If true, then remove key with null value from json result.
- remove_empty: If true, then remove any object with empty field or array with empty items.
- default_array_items: The number of items when generate array. Default is 1. If negative, then skip that field.  
    
"""


def generate_json(json_schema, args=None, remove_null=False, remove_empty=False, default_array_items=1):
    schema = json.loads(json_schema)
    args = args if args is not None else {}
    result = None
    if type(schema) is dict:
        has_value, result = _generate_object(schema, args, remove_null, remove_empty, int(default_array_items))
    elif type(schema) is list:
        has_value, result = _generate_array(schema[0], args, remove_null, remove_empty, int(default_array_items))
    return json.dumps(result, indent=4, sort_keys=True)


def random_string(size, chars):
    return ''.join(random.choice(chars) for _ in range(size))


def random_int(min, max):
    return random.randint(min, max)


def random_bool():
    return random_int(0, 1) == 1


def random_decimal(min, max, decimal_digits):
    return _round_decimal(random.uniform(min, max), decimal_digits)


def random_enum(*args):
    index = random_int(0, len(args) - 1)
    return args[index]


def _round_decimal(value, decimal_digits):
    result = Decimal(value)
    exponent = Decimal("%s" % pow(10, -Decimal(decimal_digits)))
    return result.quantize(Decimal(exponent), ROUND_HALF_UP)


def _get_key(args, key):
    if not re.search(r'\[\d+\]', key):
        return key if key in args else None
    pattern = "^" + re.sub(r"(\d)", r"(\1|\\*)", re.sub(r"(\W)", r"\\\1", key)) + "$"
    result = None
    for sub_key in sorted(args):
        matcher = re.match(pattern, sub_key)
        if matcher:
            result = sub_key
    # print("-- get key: %s - %s" % (key, result))
    return result


def _get_value(args, key, value_type):
    key = _get_key(args, key)
    if key is not None:
        value = args[key]
        if value is not None:
            if value_type in TYPE_STRINGS:
                return True, str(value)
            if value_type in TYPE_BOOLEANS:
                if type(value) is bool:
                    return True, value
                return True, str(value).lower() in ("yes", "true", "t", "1")
            if value_type in TYPE_INTEGERS:
                return True, int(value)
        else:
            return True, None
    return False, None


def _get_array(args, key):
    key = _get_key(args, key)
    if key is not None:
        value = args[key]
        if value is not None:
            if type(value) is list:
                return True, value
            elif isinstance(value, STRING_TYPE):
                return True, json.loads(value)
        else:
            return True, None
    return False, None


def _get_object(args, key):
    key = _get_key(args, key)
    if key is not None:
        value = args[key]
        if value is not None:
            if type(value) is dict:
                return True, value
            elif isinstance(value, STRING_TYPE):
                return True, json.loads(value)
        else:
            return True, None
    return False, None


def _generate_json(schema, args, remove_null, remove_empty, default_array_items, json_path):
    if isinstance(schema, STRING_TYPE):
        params = re.compile(PATTERN_PARAM_DELIMITER).split(schema.strip(), 1)
        value_type = params[0].lower()
        func = params[1] if len(params) > 1 else None
        has_value, value = _get_value(args, json_path, value_type)
        if not has_value:
            if value_type in TYPE_STRINGS:
                has_value, value = _generate_string(func)
            elif value_type in TYPE_BOOLEANS:
                has_value, value = _generate_boolean(func)
            elif value_type in TYPE_INTEGERS:
                has_value, value = _generate_integer(func)
        if not has_value or (remove_null and value is None):
            return False, None
        return True, value
    elif type(schema) is dict:
        return _generate_object(schema, args, remove_null, remove_empty, default_array_items, json_path)
    elif type(schema) is list:
        return _generate_array(schema[0], args, remove_null, remove_empty, default_array_items, json_path)
    return False, None


def _generate_array(schema, args, remove_null, remove_empty, default_array_items, json_path='$'):
    has_value, result = _get_array(args, json_path)
    if has_value:
        if not remove_empty or len(result) > 0:
            return True, result
        return False, None

    result = []
    _, size = _get_value(args, '%s.length()' % json_path, TYPE_INTEGERS[0])
    size = default_array_items if size is None else size
    if size < 0:
        return False, None
    for index in range(0, size):
        path = '%s[%s]' % (json_path, index)
        has_value, value = _generate_json(schema, args, remove_null, remove_empty, default_array_items, path)
        if has_value and (not remove_null or value is not None):
            result.append(value)

    if not remove_empty or len(result) > 0:
        return True, result
    return False, None


def _generate_object(schema, args, remove_null, remove_empty, default_array_items, json_path='$'):
    has_value, result = _get_object(args, json_path)
    if has_value:
        if not remove_empty or len(result) > 0:
            return True, result
        return False, None

    result = {}
    for key, schema in schema.items():
        path = '%s.%s' % (json_path, key)
        has_value, value = _generate_json(schema, args, remove_null, remove_empty, default_array_items, path)
        if has_value and (not remove_null or value is not None):
            result[key] = value

    if not remove_empty or len(result) > 0:
        return True, result
    return False, None


def _generate_string(func):
    if func is not None:
        value = eval(func)
        if value is None:
            return True, None
        return True, str(value)
    return False, None


def _generate_boolean(func):
    if func is not None:
        value = eval(func)
        if value is None:
            return True, None
        return True, str(value).lower() in ("yes", "true", "t", "1")
    return False, None


def _generate_integer(func):
    if func is not None:
        value = eval(func)
        if value is None:
            return True, None
        return True, int(value)
    return False, None